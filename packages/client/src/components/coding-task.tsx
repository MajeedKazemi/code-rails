import { useContext, useEffect, useRef, useState } from "react";

import { apiApplyTitle, apiGenerateFeedback, apiGetCorrectness, apiGetTitles, apiLogEvents, apiUserStartTask, apiUserSubmitTask, logError } from "../api/api";
import { AuthContext } from "../context";
import { TaskType } from "../utils/constants";
import { getLogObject } from "../utils/logger";
import { convertTime } from "../utils/shared";
import { Button } from "./button";
import { Editor } from "./editor";
import { Feedback } from "./feedback";
import { TitleSelection } from "./title-selection";

interface CodingTaskProps {
    taskId: string;
    description: string;
    output: Array<Array<string>>;
    solution: string;
    timeLimit: number;
    starterCode?: string;

    taskType: TaskType;
    showCodex: boolean;

    onCompletion: () => void;
}

export const CodingTask = (props: CodingTaskProps) => {
    const { context, setContext } = useContext(AuthContext);
    const editorRef = useRef<any>(null);

    // Personalization Setup States
    const [customTask, setCustomTask] = useState({} as {
        title: string,
        set_up: string,
        conflict: string,
        resolution: string
    });
    const [description, setDescription] = useState(props.description);
    const [output, setOutput] = useState(props.output);
    const [candidateTitles, setCandidateTitles] = useState([] as string[]);
    const [title, setTitle] = useState("");

    const [started, setStarted] = useState(false);
    const [completed, setCompleted] = useState(false);

    const [showFeedback, setShowFeedback] = useState(false);
    const [feedbackIteration, setFeedbackIteration] = useState(0);
    const [incorrectAnswer, setIncorrectAnswer] = useState(true);
    const [autoGeneratedFeedback, setAutoGeneratedFeedback] = useState({});

    const [startTime, setStartTime] = useState(Date.now());
    const [elapsedTime, setElapsedTime] = useState(0);
    const [reachedTimeLimit, setReachedTimeLimit] = useState(false);

    const [blink, setBlink] = useState(false);

    const [feedback, setFeedback] = useState("");
    const [userCode, setUserCode] = useState("");

    const [canSubmit, setCanSubmit] = useState(false);

    const sendLog = () => {
        apiLogEvents(
            context?.token,
            props.taskId,
            getLogObject(props.taskId, context?.user?.id)
        )
            .then(() => {})
            .catch((error) => {
                logError("sendLog: " + error.toString());
            });
    };

    const generateFeedback = async (correct: boolean) => {
        try {
            console.log("Generating Feedback")
            await apiGenerateFeedback(
                context?.token,
                customTask.set_up + customTask.conflict,
                userCode,
                props.solution,
                output,
                correct,
                feedbackIteration + 1,
                props.taskId
            ).then(async (resp) => {
                await resp.json().then((feedback) => {
                    setAutoGeneratedFeedback(feedback.feedback);
                });
            });
        } catch (e) {
            console.log(e);
        }
    };

    const getCorrectness = async (): Promise<boolean> => {
        try {
            console.log("Determining Correctness")
            const resp = await apiGetCorrectness(
                context?.token,
                customTask.set_up + customTask.conflict,
                userCode,
                props.solution,
                output
            )
            const correctness = await resp.json();
            return correctness.correct;
        } catch (e) {
            console.log(e);
            return false;
        }
    };

    const handleTaskFeedback = async () => {
        setAutoGeneratedFeedback({});
        setShowFeedback(true);
        setIncorrectAnswer(true);
        const pass: boolean = await getCorrectness()

        await generateFeedback(pass);
        if(pass) {
            setDescription(customTask.resolution);
            setIncorrectAnswer(false);
        } else {
            setIncorrectAnswer(true);
        }
        setFeedbackIteration(feedbackIteration + 1);
    };

    const handleSubmitTask = () => {
        apiUserSubmitTask(
            context?.token,
            props.taskId,
            {
                code: userCode,
            },
            new Date()
        )
            .then(async (response) => {
                sendLog();

                setCompleted(true);
                props.onCompletion();
            })
            .catch((error: any) => {
                logError("handleSkipTask: " + error.toString());
            });
    };

    const taskSetup = () => {
        const now = Date.now();

        apiUserStartTask(context?.token, props.taskId)
            .then(async (response) => {
                const data = await response.json();

                if (data.success) {
                    if (data.customTask && data.customTask.title) {
                        setStarted(true);
                        setCustomTask(data.customTask);

                        if (data.iteration) {
                            setFeedbackIteration(data.iteration);
                        }
                        if (data.iteration && data.iteration > 0) {
                            setAutoGeneratedFeedback(data.feedback);
                            setIncorrectAnswer(!data.correctness);
                            setShowFeedback(true);
                        }

                        if (data.correctness) {
                            setDescription(data.customTask.resolution);
                        } else {
                            setDescription(data.customTask.set_up + "<br/><br/>" + data.customTask.conflict);
                        }

                        if (data.canContinue) {
                            setStartTime(Date.parse(data.startedAt));
                            setElapsedTime(now - Date.parse(data.startedAt));
                        } else {
                            setStartTime(now);
                            setElapsedTime(now - startTime);
                        }
                    } else {
                        // Generate task titles
                        generateTitles();
                    }
                }
            })
            .catch((error: any) => {
                logError("handleStart: " + error.toString());
            });
    };

    const generateTitles = () => {
        apiGetTitles(context?.token, props.taskId, candidateTitles)
            .then(async (response) => {
                const data = await response.json();
                setCandidateTitles([...data.titles, ...candidateTitles].splice(0, 6));
            })
            .catch((error: any) => {
                logError("taskSetup: " + error.toString());
            });
    }

    const confirmTitle = () => {
        apiApplyTitle(context?.token, props.taskId, title)
            .then(async (response) => {
                const data = await response.json();
                setCustomTask(data.task);
                setDescription(data.task.set_up + "<br/><br/>" + data.task.conflict);
            })
            .catch((error: any) => {
                logError("confirmTitle: " + error.toString());
            });
        setStarted(true);
    }

    useEffect(() => {
        const id = setInterval(() => {
            setElapsedTime(Date.now() - startTime);

            // is there enough time to continue?
            if (elapsedTime / 1000 > props.timeLimit) {
                setReachedTimeLimit(true);

                if (elapsedTime / 1000 > props.timeLimit * 2) {
                    setBlink(!blink);
                }
            }
        }, 1000);

        return () => {
            clearInterval(id);
        };
    }, [startTime, elapsedTime, blink]);

    useEffect(() => {
        if (userCode.length > 0 && customTask.title) {
            setCanSubmit(true);
        } else {
            setCanSubmit(false);
        }
    }, [userCode]);

    useEffect(() => {
        taskSetup();
    }, []);

    if (!started) {
        return (
            <>
                <div className="absolute top-6 right-6">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={0.75} stroke="currentColor" className="w-12 h-12">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M17.982 18.725A7.488 7.488 0 0 0 12 15.75a7.488 7.488 0 0 0-5.982 2.975m11.963 0a9 9 0 1 0-11.963 0m11.963 0A8.966 8.966 0 0 1 12 21a8.966 8.966 0 0 1-5.982-2.275M15 9.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                    </svg>
                </div>
                <TitleSelection
                    generateTitles={generateTitles}
                    titles={candidateTitles}
                    title={title}
                    setTitle={setTitle}
                    confirmTitle={confirmTitle}
                />
            </>
        );
    }

    return (
        <div className="flex flex-col p-4 gap-4 min-h-full">
            <div className="flex gap-4 flex-grow">
                <section className="flex-auto task-info max-w-lg">
                    <div className="task-description-container">
                        {customTask.title ?
                            <>
                                <span className="task-title">{customTask.title}</span>
                                <span className={"task-subtitle flex flex-col gap-2 overflow-y-auto" + (autoGeneratedFeedback.hasOwnProperty("feedback") ? " max-h-72" : "")}>
                                    <p
                                    dangerouslySetInnerHTML={{
                                        __html: description,
                                    }} />
                                </span>
                                <div className="flex flex-row w-full justify-end">
                                    {description === customTask.resolution ?
                                        <button onClick={() => setDescription(customTask.set_up + "<br/><br/>" + customTask.conflict)}>
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                                                <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
                                            </svg>
                                        </button>
                                    :
                                        <>{!incorrectAnswer && 
                                            <button onClick={() => setDescription(customTask.resolution)}>
                                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                                                    <path strokeLinecap="round" strokeLinejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
                                                </svg>
                                            </button>
                                        }</>
                                    }
                                </div>
                            </>
                        :
                            <div className="flex flex-row gap-2 bg-white px-6 py-3 rounded-3xl border border-slate-300">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="animate-spin w-6 h-6">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
                                </svg>
                                Generating Task Information
                            </div>
                        }

                        {feedback ? (
                            <div className="task-feedback-container">
                                <span className="feedback-header">Feedback:</span>
                                <span className="feedback-content">{feedback}</span>
                            </div>
                        ) : null}
                    </div>

                    <div className="task-submission-buttons-container">
                        {!showFeedback && <div>
                            <Button
                                class={blink ? "btn-attention" : ""}
                                onClick={handleTaskFeedback}
                                type="block"
                                disabled={!canSubmit}
                            >
                                Submit for Feedback
                            </Button>

                            {reachedTimeLimit ? (
                                <div className="submit-urgent-message">
                                    <span>Please submit the code sooner!</span>

                                    <span className="time-indicator">
                                        {convertTime(elapsedTime / 1000)}
                                    </span>
                                </div>
                            ) : null}
                        </div>}

                        {showFeedback && <div className="flex flex-col gap-2">
                            <Feedback 
                                feedback={autoGeneratedFeedback}
                                iteration={feedbackIteration}
                            />
                            {autoGeneratedFeedback.hasOwnProperty("type") && ((!incorrectAnswer || feedbackIteration >= 3) ? 
                                <Button
                                    class={blink ? "btn-attention" : ""}
                                    onClick={handleSubmitTask}
                                    type="block"
                                    disabled={!canSubmit}
                                >
                                    Start Next Task
                                </Button>
                                :
                                <Button
                                    class={blink ? "btn-attention" : ""}
                                    onClick={handleTaskFeedback}
                                    type="block"
                                    disabled={!canSubmit}
                                >
                                    Resubmit
                                </Button>)
                            }
                        </div>}
                    </div>
                </section>

                <Editor
                    ref={editorRef}
                    showCodex={props.showCodex}
                    taskId={props.taskId}
                    starterCode={props.starterCode ? props.starterCode : ""}
                    updateCode={setUserCode}
                />
            </div>
        </div>
    );
};
