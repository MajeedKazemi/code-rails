import { Fragment, useContext, useEffect, useRef, useState } from "react";

import { apiGenerateFeedback, apiGetCorrectness, apiLogEvents, apiUserStartTask, apiUserSubmitTask, logError } from "../api/api";
import { AuthContext } from "../context";
import { TaskType } from "../utils/constants";
import { getLogObject } from "../utils/logger";
import { convertTime } from "../utils/shared";
import { Button } from "./button";
import { Editor } from "./editor";
import { Feedback } from "./feedback";

interface CodingTaskProps {
    taskId: string;
    description: string;
    output: Array<Array<string>>;
    solution: string;
    timeLimit: number;
    starterCode?: string;

    taskType: TaskType;
    showCodex: boolean;

    onCompletion: () => void;
}

export const CodingTask = (props: CodingTaskProps) => {
    const { context, setContext } = useContext(AuthContext);
    const editorRef = useRef<any>(null);

    const [started, setStarted] = useState(false);
    const [completed, setCompleted] = useState(false);

    const [showFeedback, setShowFeedback] = useState(false);
    const [feedbackIteration, setFeedbackIteration] = useState(0);
    const [incorrectAnswer, setIncorrectAnswer] = useState(true);
    const [autoGeneratedFeedback, setAutoGeneratedFeedback] = useState({});

    const [startTime, setStartTime] = useState(Date.now());
    const [elapsedTime, setElapsedTime] = useState(0);
    const [reachedTimeLimit, setReachedTimeLimit] = useState(false);

    const [blink, setBlink] = useState(false);

    const [feedback, setFeedback] = useState("");
    const [userCode, setUserCode] = useState("");

    const [canSubmit, setCanSubmit] = useState(false);

    const sendLog = () => {
        apiLogEvents(
            context?.token,
            props.taskId,
            getLogObject(props.taskId, context?.user?.id)
        )
            .then(() => {})
            .catch((error) => {
                logError("sendLog: " + error.toString());
            });
    };

    const generateFeedback = async (correct: boolean) => {
        try {
            console.log("Generating Feedback")
            await apiGenerateFeedback(
                context?.token,
                props.description,
                userCode,
                props.solution,
                props.output,
                correct,
                feedbackIteration + 1,
                props.taskId
            ).then(async (resp) => {
                await resp.json().then((feedback) => {
                    setAutoGeneratedFeedback(feedback.feedback);
                });
            });
        } catch (e) {
            console.log(e);
        }
    };

    const getCorrectness = async (): Promise<boolean> => {
        try {
            console.log("Determining Correctness")
            const resp = await apiGetCorrectness(
                context?.token,
                props.description,
                userCode,
                props.solution,
                props.output
            )
            const correctness = await resp.json();
            return correctness.correct;
        } catch (e) {
            console.log(e);
            return false;
        }
    };

    const handleTaskFeedback = async () => {
        setAutoGeneratedFeedback({});
        setShowFeedback(true);
        setIncorrectAnswer(true);
        const pass: boolean = await getCorrectness()

        await generateFeedback(pass);
        if(pass) {
            setIncorrectAnswer(false);
        } else {
            setIncorrectAnswer(true);
        }
        setFeedbackIteration(feedbackIteration + 1);
    };

    // TODO: Remove Resubmission Function
    const resubmitFeedback = async () => {
        setAutoGeneratedFeedback({});
        setShowFeedback(true);
        setIncorrectAnswer(true);
        const pass: boolean = await getCorrectness()

        await generateFeedback(pass);
        if(pass) {
            setIncorrectAnswer(false);
        } else {
            setIncorrectAnswer(true);
        }
    };

    const handleSubmitTask = () => {
        apiUserSubmitTask(
            context?.token,
            props.taskId,
            {
                code: userCode,
            },
            new Date()
        )
            .then(async (response) => {
                sendLog();

                setCompleted(true);
                props.onCompletion();
            })
            .catch((error: any) => {
                logError("handleSkipTask: " + error.toString());
            });
    };

    const handleStart = () => {
        const now = Date.now();

        apiUserStartTask(context?.token, props.taskId)
            .then(async (response) => {
                const data = await response.json();

                if (data.success) {
                    setStarted(true);

                    if (data.canContinue) {
                        if (data.feedback) {
                            setFeedback(data.feedback);
                        }

                        setStartTime(Date.parse(data.startedAt));
                        setElapsedTime(now - Date.parse(data.startedAt));
                    } else {
                        setStartTime(now);
                        setElapsedTime(now - startTime);
                    }
                }
            })
            .catch((error: any) => {
                logError("handleStart: " + error.toString());
            });
    };

    useEffect(() => {
        const id = setInterval(() => {
            setElapsedTime(Date.now() - startTime);

            // is there enough time to continue?
            if (elapsedTime / 1000 > props.timeLimit) {
                setReachedTimeLimit(true);

                if (elapsedTime / 1000 > props.timeLimit * 2) {
                    setBlink(!blink);
                }
            }
        }, 1000);

        return () => {
            clearInterval(id);
        };
    }, [startTime, elapsedTime, blink]);

    useEffect(() => {
        if (userCode.length > 0) {
            setCanSubmit(true);
        } else {
            setCanSubmit(false);
        }
    }, [userCode]);

    if (!started) {
        return (
            <div className="container">
                <div className="card p-md">
                    <p>
                        You have{" "}
                        <span className="remaining-time">
                            {convertTime(props.timeLimit)} minutes
                        </span>{" "}
                        to finish this task.
                    </p>
                    <button className="btn btn-primary" onClick={handleStart}>
                        Start task
                    </button>
                </div>
            </div>
        );
    }

    return (
        <div className="flex flex-col p-4 gap-4 min-h-full">
            <div className="flex gap-4 flex-grow">
                <section className="flex-auto task-info max-w-lg">
                    <div className="task-description-container">
                        <span className="task-title">Task Description:</span>
                        <span className="task-subtitle">
                            <p
                                dangerouslySetInnerHTML={{
                                    __html: props.description,
                                }}
                            ></p>
                        </span>

                        <span className="task-sample-output-header">Sample:</span>
                        {props.output.map((lines, i) => {
                            return (
                                <div
                                    key={`sample-out-key-${i}`}
                                    className="task-sample-output"
                                >
                                    <span>
                                        {lines.map((line, j) => {
                                            return (
                                                <p
                                                    key={`sample-line-key-${j}`}
                                                    dangerouslySetInnerHTML={{
                                                        __html: line,
                                                    }}
                                                ></p>
                                            );
                                        })}
                                    </span>
                                </div>
                            );
                        })}

                        {feedback ? (
                            <div className="task-feedback-container">
                                <span className="feedback-header">Feedback:</span>
                                <span className="feedback-content">{feedback}</span>
                            </div>
                        ) : null}
                    </div>

                    <div className="task-submission-buttons-container">
                        {!showFeedback && <div>
                            <div className="submit-attention">
                                <b>ATTENTION</b>
                                <br />
                                <br />
                                You can only submit <b>ONCE</b>. So please double-check your
                                solution before submitting.
                            </div>
                            <br />
                            
                            <Button
                                class={blink ? "btn-attention" : ""}
                                onClick={handleTaskFeedback}
                                type="block"
                                disabled={!canSubmit}
                            >
                                Submit for Feedback
                            </Button>

                            {reachedTimeLimit ? (
                                <div className="submit-urgent-message">
                                    <span>Please submit the code sooner!</span>

                                    <span className="time-indicator">
                                        {convertTime(elapsedTime / 1000)}
                                    </span>
                                </div>
                            ) : null}
                        </div>}

                        {showFeedback && <div className="flex flex-col gap-2">
                            <div className="flex flex-row gap-2">
                                <button onClick={resubmitFeedback} type="button" className="grow focus:outline-none text-white bg-purple-700 hover:bg-purple-800 focus:ring-4 focus:ring-purple-300 font-medium rounded-full text-sm px-5 py-2.5 mb-2 dark:bg-purple-600 dark:hover:bg-purple-700 dark:focus:ring-purple-900">Regenerate</button>
                                <button type="button" className="grow cursor-default focus:outline-none text-white bg-purple-700 focus:ring-4 focus:ring-purple-300 font-medium rounded-full text-sm px-5 py-2.5 mb-2 dark:bg-purple-600 dark:focus:ring-purple-900">Iteration: {feedbackIteration}</button>
                            </div>

                            <Feedback 
                                feedback={autoGeneratedFeedback}
                                iteration={feedbackIteration}
                            />
                            {autoGeneratedFeedback.hasOwnProperty("type") && ((!incorrectAnswer || feedbackIteration >= 3) ? 
                                <Button
                                    class={blink ? "btn-attention" : ""}
                                    onClick={handleSubmitTask}
                                    type="block"
                                    disabled={!canSubmit}
                                >
                                    Start Next Task
                                </Button>
                                :
                                <Button
                                    class={blink ? "btn-attention" : ""}
                                    onClick={handleTaskFeedback}
                                    type="block"
                                    disabled={!canSubmit}
                                >
                                    Resubmit
                                </Button>)
                            }
                        </div>}
                    </div>
                </section>

                <Editor
                    ref={editorRef}
                    showCodex={props.showCodex}
                    taskId={props.taskId}
                    starterCode={props.starterCode ? props.starterCode : ""}
                    updateCode={setUserCode}
                />
            </div>
        </div>
    );
};
